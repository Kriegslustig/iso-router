/**
 * An object defined by the `connect` npm package. Meteor uses this internally and I'm just hooking into it.
 * @typedef {object} connectHandle
 * @prop {object} req - Documented in the nodejs HTTP package
 * @prop {object} res - Documented in the nodejs HTTP package
 * @prop {object} next - The next function on the connect stack. Documented inside the connect npm package.
 */

/**
 * An Array containing the result of `Route.pathRegex.exec`. Here's an example:
 *
 * ```js
 * IsoRouter.route('/:some/:other')
 *   .action(console.log.bind(console))
 * IsoRouter.navigate('/something/else')
 * ```
 *
 * This will log the following:
 *
 * ```js
 * [ '/something/else', 'something', 'else' ]
 * ```
 *
 * @typedef {array} pathToRegexMatch
 */

/**
 * @namespace
 */
Route = {}

/**
 * The path the route is for
 * @locus anywhere
 * @type {string}
 */
Route.path = undefined

/**
 * The paresed regex for the path
 * @locus {anywhere}
 * @type {regexp}
 */
Route.pathRegex = undefined

/**
 * The array generated by pathToRegex (largely for internal use)
 * @locus {anywhere}
 * @type {array}
 */
Route.key = undefined

Route.set = function routeSet (key, value) {
  this[key] = (typeof value == 'function') ? value() : value
  return this
}

/**
 * This adds a listener to an event which is only called when the route set in the event object.
 * @argument {string} eventName - The name of the event to listen for
 * @argument {eventCallback} callback - A function to be called when the event is dispatched and the route matches
 */
Route.addListener = function RouteAddListener (type, callback) {
  addListener(type, (e) => {
    if(this.path && e.route.path !== this.path) return
    callback.call(this, e)
  })
  return this
}

Route.appendListener = function (type, callback) {
  appendListener(type, (e) => {
    if(this.path && e.route.path !== this.path) return
    callback.call(this, e)
  })
  return this
}

/**
 * Calls pathRegex.exec
 * @locus anywhere
 * @param {string} url - The url to execute the regex on
 * @return {false|array} Returns false if the test fails and returns the exec's return on success
 */
Route.match = function routeMatch (url) {
  if(!this.pathRegex.test(url)) return false
  return this.pathRegex.exec(url)
}

/**
 * Calls route.match and maps the resulting array to the parameter names in the route's path.
 * @param {string} url
 * @return {object|false} Returns an object mapping params to their values
 */
Route.matchToObject = function RouteMatchToObject (url) {
  if(!this.pathRegex) return
  var match = this.match(url)
  return _.object(_.clone(this.keys).map(function (key, i) {
    return [key.name, match[i + 1]]
  }))
}

