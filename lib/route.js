/**
 * An object defined by the `connect` npm package. Meteor uses this internally and I'm just hooking into it.
 * @typedef {object} connectHandle
 * @prop {object} req - Documented in the nodejs HTTP package
 * @prop {object} res - Documented in the nodejs HTTP package
 * @prop {object} next - The next function on the connect stack. Documented inside the connect npm package.
 */

/**
 * An Array containing the result of `Route.pathRegex.exec`. Here's an example:
 *
 * ```js
 * IsoRouter.route('/:some/:other')
 *   .action(console.log.bind(console))
 * IsoRouter.navigate('/something/else')
 * ```
 *
 * This will log the following:
 *
 * ```js
 * [ '/something/else', 'something', 'else' ]
 * ```
 *
 * @typedef {array} pathToRegexMatch
 */

/**
 * @namespace
 */
Route = {}

/**
 * The path the route is for
 * @locus anywhere
 * @type {string}
 */
Route.path = undefined

/**
 * The paresed regex for the path
 * @locus {anywhere}
 * @type {regexp}
 */
Route.pathRegex = undefined

/**
 * The array returned by pathRegex.exec
 * @locus {anywhere}
 * @type {array}
 */
Route.parameters = undefined

/**
 * The array generated by pathToRegex (largely for internal use)
 * @locus {anywhere}
 * @type {array}
 */
Route.key = undefined

/**
 * The incomming request object
 * @locus server
 * @type {connectHandle.req}
 */
Route.req = undefined

/**
 * The connection's response object
 * @locus server
 * @type {connectHandle.res}
 */
Route.res = undefined

/**
 * The next middleware on the connection stack
 * @locus server
 * @type {connectHandle.next}
 */
Route.next = undefined

Route._actionValue = undefined
Route._actionGlobalValue = function () {
  IsoRouter.next()
}

/**
 * Define an action that should be triggered when the route is called. This can also called on the global `IsoRouter.Route` This will set a default action.
 * @locus anywhere
 * @param {action} action
 * @return {Route}
 */
Route.action = function routeAction (action) {
  if(!Route.isPrototypeOf(this)) {
    Route._actionGlobalValue = action
  } else {
    this._actionValue = action
  }
  return this
}
/**
 * A function that is called when the client navigates to a route.
 * @callback action
 * @param {pathToRegexMatch} params - The array returned by pathRegex.exec
 */

Route._enterValue = undefined
Route._enterGlobalValue = []

/**
 * Add enter hooks to the route. This can also called on the global `IsoRouter.Route`. It will add default hooks which will always be called.
 * @locus anywhere
 * @param {enterHook} enter - An enter hook to be added to the route
 * @return {Route}
 */
Route.enter = function routeEnter (enter) {
  if(!Route.isPrototypeOf(this)) {
    this._enterGlobalValue.push(enter)
  } else {
    this._enterValue = this._enterValue || []
    this._enterValue.push(enter)
  }
  return this
}
/**
 * The `enterHooks` of a route are called before the action is called. When you set global `enterHooks` they will be triggered on each route. Even if the route has it's own. These hooks are executed asynchronously. For that purpose a parameter `next` is passed. It must be called in order to trigger the next enter hook. It must also be called on the last enter hook for the `action` to be called.
 * @callback enterHook
 * @param {pathToRegexMatch} params - The array returned by pathRegex.exec
 * @param {next} params - The next `enter` hook to be called
 */

Route._exitValue = undefined
Route._exitGlobalValue = []

/**
 * Adds an exit hook. This can also called on the global `IsoRouter.Route`. It will add a default hook which will always be called.
 * @locus anywhere
 * @param {exitHook} exit - The exit hook to add
 * @return {Route}
 */
Route.exit = function routeExit (exit) {
  if(!Route.isPrototypeOf(this)) {
    this._exitGlobalValue.push(exit)
  } else {
    this._exitValue = this._exitValue || []
    this._exitValue.push(exit)
  }
  return this
}
/**
 * On the client `exitHook`s are called when a client navigates to an other route. When you set a global `exitHook` it will be triggered on each route. Even if the route has it's own.
 * @callback exitHook
 * @param {next} params - The next `exit` hook to be called
 */

Route.set = function routeSet (key, value) {
  this[key] = (typeof value == 'function') ? value() : value
  return this
}

Route.call = function routeCall (key, ...args) {
  var func = (this[['_', 'Value'].join(key)] || this[['_', 'GlobalValue'].join(key)])
  if(typeof func != 'function') return this
  func.apply(this, args)
  return this
}

Route.callAll = function routeCallAll (key, parameters, callback, arr) {
  arr = arr ?
    arr :
    pushIf(
      [],
      this[['_', 'GlobalValue'].join(key)],
      this[['_', 'Value'].join(key)],
      callback
    )
  if(arr.length > 0) {
    arr.shift()
      .apply(this, pushIf([], parameters, this.callAll.bind(this, key, parameters, null, arr)))
  }
  return this
}

/**
 * Calls pathRegex.exec
 * @locus anywhere
 * @param {string} url - The url to execute the regex on
 * @return {false|array} Returns false if the test fails and returns the exec's return on success
 */
Route.match = function routeMatch (url) {
  if(!this.pathRegex.test(url)) return false
  return this.pathRegex.exec(url)
}

/**
 * Calls route.match and maps the resulting array to the parameter names in the route's path.
 * @param {string} url
 * @return {object|false} Returns an object mapping params to their values
 */
Route.matchToObject = function RouteMatchToObject (url) {
  var match = this.match(url)
  return _.object(_.clone(this.keys).map(function (key, i) {
    return [key.name, match[i + 1]]
  }))
}
